load cassandra-aux-smc
load sampler

mod CASSANDRA is
  inc CASSANDRA-AUX .
  inc SCHEDULER .

  var K : Key .  vars V V' : Value .  var CL : ConsistLevel .
  var RPS : Set{RingPair} .  var LOCKS : Set{LockedKey} .  var OP : Operation .
  vars O TID RID A A' S S' : Address . vars AS AS' : AttributeSet .
  vars TXNS TXNS' CONFIG : Config .  vars TRANSES TRANSES' : ConfigList . 
  vars VERSION VERSION' : Version .
  var WS : Set{KeyValue} .  var RS : Set{KeyVersion} . 
  var RESPONSES : Responses . var RCL : ReqConsLv .
  var RIDS : AddressSet . var DS : Set{KeyValueVersion} .
  var RSET : ResponseSet . vars KVV KVV' : KeyValueVersion .  var FLAG : Bool . 
  var SL : ScheduleList .  

  var O@M : Address .  var LOG@M : Log .
  vars VTS1@M VTS2@M : VectorTime . var FLAG@M : Bool . 
  vars READS@M WRITES@M : Set{KeyVersion} .
  vars GT GT' : Float . 


  rl [rcv-start-when-no-txn] :
     < A : Client | requestQueue: emptyTxnList, AS > 
     {GT, start to A} 
   =>
     < A : Client | requestQueue: emptyTxnList, AS > .


  rl [dequeue] :
     < O@M : Monitor | log: LOG@M >
     < A : Client | requestQueue: (< TID : Txn | operations: OP, AS' > ;; TRANSES),
                    waitingList: TRANSES',
                    lockedKeys: LOCKS,
                    executing: TXNS, AS > 
     {GT, start to A} 
   =>
     if isLocked(OP,LOCKS)
       then < O@M : Monitor | log: LOG@M >
            < A : Client | requestQueue: TRANSES,
                           waitingList: (TRANSES' ;; < TID : Txn | operations: OP, AS' >),
                           lockedKeys: LOCKS,
                           executing: TXNS, AS >  
       else < O@M : Monitor | log: 
              insert(TID,< A |-> GT,empty,false,empty,empty >,LOG@M) >
            < A : Client | requestQueue: TRANSES,
                           waitingList: TRANSES',
                           lockedKeys: (lock(TID,OP),LOCKS),
                           executing: (< TID : Txn | operations: OP, AS' > TXNS), AS > 
     fi .


 crl [waiting-dequeue] :
     < O@M : Monitor | log: LOG@M >
     < A : Client | waitingList: (TRANSES ;; < TID : Txn | operations: OP, AS' > ;; TRANSES'),
                    lockedKeys: LOCKS,
                    executing: TXNS, AS > 
     { GT | SL }
   =>
     < O@M : Monitor | log: 
              insert(TID,< A |-> GT,empty,false,empty,empty >,LOG@M) >
     < A : Client | waitingList: (TRANSES ;; TRANSES'),
                    lockedKeys: (lock(TID,OP),LOCKS),
                    executing: (< TID : Txn | operations: OP, AS' > TXNS), AS > 
     { GT | SL }
     if not isLocked(OP,LOCKS) .

  *** NEW
  eq eagerEnabled(< A : Client | waitingList: (TRANSES ;; < TID : Txn | operations: OP, AS' > ;; TRANSES'),
                    lockedKeys: LOCKS,
                    executing: TXNS, AS > CONFIG) = true .

  rl [read-from-client-to-coord] :
     { GT | SL }
     < A : Client | executing: (< TID : Txn | operations: read(K),
                                              consLv: CL, AS' > TXNS),
                    coord: S, AS >
   =>
     { GT | SL }
     < A : Client | executing: (< TID : Txn | operations: nil,
                                              consLv: CL, AS' > TXNS),
                    coord: S, AS >
     [delay + GT, msg request(TID,read(K),CL) from A to S] .

  *** NEW
  eq eagerEnabled(< A : Client | executing: (< TID : Txn | operations: read(K),
                                                           consLv: CL, AS' > TXNS),
                                 coord: S, AS > CONFIG) = true .


  rl [write-from-client-to-coord] :
     { GT | SL }
     < A : Client | executing: (< TID : Txn | operations: write(K,V),
                                              consLv: CL, 
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    coord: S, AS >
   =>
     { GT | SL }
     < A : Client | executing: (< TID : Txn | operations: nil,
                                              consLv: CL,
                                              writeSet: (WS,< K,V >),
                                              version: GT, AS' > TXNS),
                    coord: S, AS >
     [delay + GT, msg request(TID,write(K,V),GT,CL) from A to S] .

  *** NEW
  eq eagerEnabled(< A : Client | executing: (< TID : Txn | operations: write(K,V),
                                              consLv: CL, 
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    coord: S, AS > CONFIG) = true .


  rl [read-from-coord-to-repl] :
     < S : Server | localRing: RPS,
                    reqConsLv: RCL,
                    respFromRepl: RESPONSES, AS >
     {GT, msg request(TID,read(K),CL) from A to S}
   => 
     < S : Server | localRing: RPS,
                    reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: insert(TID,empty,RESPONSES), AS > 
     genReadRequests(GT,TID,K,nextNAddresses([K],RPS,replicaFactor),S) . 

  op genReadRequests : Float Address Key AddressSet Address -> Config .
  eq genReadRequests(GT,TID,K,(RID ; RIDS),S) = 
       [delay + GT, msg readRequest(TID,K) from S to RID]
       genReadRequests(GT,TID,K,RIDS,S) .
  eq genReadRequests(GT,TID,K,empty,S) = null .


  rl [write-from-coord-to-repl] :
     < S : Server | localRing: RPS,
                    reqConsLv: RCL,
                    respFromRepl: RESPONSES, AS >
     {GT, msg request(TID,write(K,V),GT',CL) from A to S}
   => 
     < S : Server | localRing: RPS,
                    reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: insert(TID,empty,RESPONSES), AS > 
     genWriteRequests(GT,TID,K,V,GT',nextNAddresses([K],RPS,replicaFactor),S) . 

  op genWriteRequests : Float Address Key Value Version AddressSet Address -> Config .
  eq genWriteRequests(GT,TID,K,V,VERSION,(RID ; RIDS),S) = 
       [delay + GT, msg writeRequest(TID,[K,V,VERSION]) from S to RID]
       genWriteRequests(GT,TID,K,V,VERSION,RIDS,S) .
  eq genWriteRequests(GT,TID,K,V,VERSION,empty,S) = null .


  rl [read-from-repl-to-coord] :
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     {GT, msg readRequest(TID,K) from S to RID}
   => 
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     [delay + GT, msg readResponse(TID,[K,V,VERSION]) from RID to S] .


  rl [write-from-repl-to-coord] :
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     {GT, msg writeRequest(TID,[K,V',VERSION']) from S to RID}
   => 
     if VERSION' >= VERSION
       then < RID : Server | datastore: (DS, [K,V',VERSION']), AS >
            [delay + GT, msg writeResponse(TID,true) from RID to S]
       else < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
            [delay + GT, msg writeResponse(TID,false) from RID to S]
     fi .


 rl [read-at-coord] : 
     < S : Server | respFromRepl: (TID |-> RSET,RESPONSES), AS >
     {GT, msg readResponse(TID,KVV) from RID to S} 
   =>
     < S : Server | respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS > .

  rl [write-at-coord] : 
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> RSET,RESPONSES), AS >
     {GT, msg writeResponse(TID,FLAG) from RID to S} 
   =>
     if CL == | (response(RID,FLAG),RSET) |
       then < S : Server | reqConsLv: RCL,
                           respFromRepl: (TID |-> (response(RID,FLAG),RSET),RESPONSES), AS >
            [delay + GT, done(TID,resultForWrite((response(RID,FLAG),RSET)))]
       else < S : Server | reqConsLv: (RCL ; [TID,CL]),
                           respFromRepl: (TID |-> (response(RID,FLAG),RSET),RESPONSES), AS >
     fi .


 crl [write-at-coord-later-coming] : 
     < S : Server | reqConsLv: RCL,
                    respFromRepl: (TID |-> RSET,RESPONSES), AS >
     {GT, msg writeResponse(TID,FLAG) from RID to S} 
   =>
     < S : Server | reqConsLv: RCL,
                    respFromRepl: (TID |-> (response(RID,FLAG),RSET),RESPONSES), AS >
     if not (TID in RCL) .  


 crl [from-coord-to-client-readrepair] : 
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
     {GT | SL}
   =>
     < S : Server | reqConsLv: RCL,
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
     genReadRepairs(GT,(response(RID,KVV),RSET),S)
     [delay + GT, done(TID,resultForRead((response(RID,KVV),RSET)))]
     if | (response(RID,KVV),RSET) | == replicaFactor .   

  op genReadRepairs : Float ResponseSet Address -> Config .
  eq genReadRepairs(GT,RSET,S) = 
       $genReadRepairs(GT,resultForRead(RSET),repairReplicas(resultForRead(RSET),RSET),S) .
  
  op $genReadRepairs : Float KeyValueVersion AddressSet Address -> Config .
  eq $genReadRepairs(GT,KVV,(RID ; RIDS),S) =
       [delay + GT, msg readRepair(KVV) from S to RID]
       $genReadRepairs(GT,KVV,RIDS,S) .
  eq $genReadRepairs(GT,KVV,empty,S) = null .



  rl [readrepair] :
     < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     {GT, msg readRepair([K,V',VERSION']) from S to RID}
   => 
     if VERSION' >= VERSION
       then < RID : Server | datastore: (DS, [K,V',VERSION']), AS >
       else < RID : Server | datastore: (DS, [K,V,VERSION]), AS >
     fi .


 crl [from-coord-to-client] : 
     < S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS >
     { GT | SL }
   =>
     < S : Server | reqConsLv: RCL,
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS > 
     { GT | SL }
     [delay + GT, done(TID,resultForRead((response(RID,KVV),RSET))) ]
     if | (response(RID,KVV),RSET) | =/= replicaFactor /\
        | (response(RID,KVV),RSET) | == CL .  


  *** NEW
 ceq eagerEnabled(< S : Server | reqConsLv: (RCL ; [TID,CL]),
                    respFromRepl: (TID |-> (response(RID,KVV),RSET),RESPONSES), AS > CONFIG) 
   = true if | (response(RID,KVV),RSET) | =/= replicaFactor /\
        | (response(RID,KVV),RSET) | == CL .


  rl [rcv-done-read] :
     < O@M : Monitor | log: (TID |-> 
        < VTS1@M,VTS2@M,FLAG@M,READS@M,WRITES@M >,LOG@M) > 
     < A : Client | executing: (< TID : Txn | readSet: RS,
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    committed: TXNS', 
                    lockedKeys: (lockedKey(TID,K),LOCKS), AS >
     {GT, done(TID,[K,V,VERSION'])}
   =>
     < O@M : Monitor | log: (TID |-> 
        < VTS1@M,insert(A,GT,VTS2@M),true,(RS,< K,VERSION' >),kver(WS,VERSION) >,LOG@M) >
     < A : Client | executing: TXNS,
                    committed: (TXNS' < TID : Txn | readSet: (RS,< K,VERSION' >),
                                                    writeSet: WS,
                                                    version: VERSION, AS' >), 
                    lockedKeys: LOCKS, AS >
     {delay + GT, start to A} .


  rl [rcv-done-write] :
     < O@M : Monitor | log: (TID |-> 
        < VTS1@M,VTS2@M,FLAG@M,READS@M,WRITES@M >,LOG@M) > 
     < A : Client | executing: (< TID : Txn | readSet: RS,
                                              writeSet: WS,
                                              version: VERSION, AS' > TXNS),
                    committed: TXNS',
                    lockedKeys: (lockedKey(TID,K),LOCKS), AS >
     {GT, done(TID,FLAG)}
   =>
     < O@M : Monitor | log: (TID |-> 
        < VTS1@M,insert(A,GT,VTS2@M),true,RS,kver(WS,VERSION) >,LOG@M) >
     < A : Client | executing: TXNS,
                    committed: (TXNS' < TID : Txn | readSet: RS,
                                                    writeSet: WS,
                                                    version: VERSION, AS' >),
                    lockedKeys: LOCKS, AS >
     {delay + GT, start to A} .

endm
